---
title: "数据类型精度"
date: 2026-02-28
tags: ["OP"]
---

# 数据类型精度
---

## 常用数据类型

| 数据类型 | bits |数值范围 | 数值精度 | 符号位S | 指数位E | 尾数位M | 适用场景 |
|-------|-------|-------|-------|-------|-------|-------|-------|
| FP32 | 32 | $-3.4 \times 10^{38}\sim {3.4}\times 10^{38}$| $10^{-6}$ | 1 | 8 | 23 |
| TF32 | 19 |  $-3.4 \times 10^{38}\sim {3.4}\times 10^{38}$|  $10^{-3}$ | 1 | 8 | 10 |
| FP16 | 16 | $-65504\sim\ 65504$ | $10^{-3}$ | 1 | 5 | 10 | 
| BF16 | 16 | $-3.39 \times 10^{38}\sim {3.39}\times 10^{38}$|  $10^{-2}$ | 1 | 8 | 7 |
| INT32 | 32 | $-2.15 \times  10^{9}\sim {2.15} \times 10^{9}$ | 1 | 1 | 
| INT16 | 16 | $-32768 \sim 32768$ | 1 | 1 |
| FP8(E5M2) | 8 | $-57344 \sim 57344$, +/-inf, nan |  | 1 | 5 | 2 |
| fp8(E4M3) | 8 | $-448 \sim 448$, nan |  | 1 | 4 | 3 | 
| INT8 | 8 | $-128\sim 127$ | 1 | 1 |

## 浮点数存储结构

浮点数的真值表示为：
**Value = (-1)^S × (1 + M) × 2^(E - Bias)**

## 大数吃小数的原因：浮点数计算对阶过程导致

### 浮点数运算步骤：
对阶->尾数求和->规格化
1. 对阶：  
    为什么要对阶：就像十进制的科学记数法一样，你要计算 $1.2 \times 10^3 + 3.4 \times 10^2$，必须先让它们的指数一样，才能把前面的有效数字相加  
    对阶过程精度损失：  
    假设一个浮点数的真实值为 V，尾数为 M，阶码为 E：
    $$V = M \times 2^E$$  
    在对阶过程中，如果你把较小的阶码 E 加上了 ΔE（使其等于较大的那个阶码），为了保证浮点数的总值 V 依然不变，你的尾数 M 就必须缩小相应的倍数：  
    $$V = \left(M \times 2^{-\Delta E}\right) \times 2^{E + \Delta E}$$  
    乘以 $2^{-\Delta E}$（即除以 $2^{\Delta E}$）的物理操作，就是将尾数的二进制位向右平移 $\Delta E$ 位，这个过程就右尾数精度丢失了
2. 尾数求和
3. 规格化

### 尽可能的避免方法
先小数计算，最后结果再与大数计算

